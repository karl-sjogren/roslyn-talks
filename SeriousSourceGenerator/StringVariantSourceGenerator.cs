using System.Globalization;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace SeriousSourceGenerator;

[Generator]
public class StringVariantSourceGenerator : IIncrementalGenerator {
    private const string _markerAttributeName = "SeriousSourceGenerator.GenerateStringVariantsAttribute";

    private static Regex _kebabCaseRegex = new Regex("(?<!^)([A-Z][a-z]|(?<=[a-z])[A-Z0-9])");

    public void Initialize(IncrementalGeneratorInitializationContext context) {
        var propertiesToGenerate = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                _markerAttributeName,
                predicate: CheckIfValidProperty,
                transform: GetSourcePropertyInfo)
            .Where(static m => m is not null);

        context.RegisterSourceOutput(propertiesToGenerate, Execute);
    }

    private static void Execute(SourceProductionContext context, SourcePropertyInfo? propertyToGenerate) {
        if(!(propertyToGenerate is { } property)) {
            return;
        }

        var sb = new StringBuilder();
        var value = property.PropertyInitializerValue;
        var textInfo = new CultureInfo("en-US",false).TextInfo;

        sb.AppendLine("//------------------------------------------------------------------------------");
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("//     This code was geneted by " + nameof(StringVariantSourceGenerator) + ".");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine("//------------------------------------------------------------------------------");
        sb.AppendLine();

        sb.AppendLine("namespace " + property.Namespace + ";");
        sb.AppendLine();
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine($"{property.ClassModifier} partial class {property.ClassName} {{");
        sb.AppendLine($"    public string {property.PropertyName}UpperCase {{ get; }} = \"{value.ToUpperInvariant()}\";");
        sb.AppendLine($"    public string {property.PropertyName}LowerCase {{ get; }} = \"{value.ToLowerInvariant()}\";");
        sb.AppendLine($"    public string {property.PropertyName}TitleCase {{ get; }} = \"{textInfo.ToTitleCase(value)}\";");

        if(!value.Contains(" ")) {
            sb.AppendLine($"    public string {property.PropertyName}KebabCase {{ get; }} = \"{_kebabCaseRegex.Replace(value, "-$1").ToLowerInvariant()}\";");
        }

        sb.AppendLine("}");

        context.AddSource(property.ClassName + "_" + property.PropertyName + "_StringVariants.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static bool CheckIfValidProperty(SyntaxNode node, CancellationToken _) {
        if(node is not PropertyDeclarationSyntax propertySyntax) {
            return false;
        }

        if(propertySyntax.Type.ToString() is not "string" and not "string?") {
            return false;
        }

        if(propertySyntax.AccessorList is null) {
            return false;
        }

        if(propertySyntax.AccessorList.Accessors.Any(a => a.Kind() == SyntaxKind.SetAccessorDeclaration)) {
            return false;
        }

        if(propertySyntax.AccessorList.Accessors.Any(a => a.Body is not null)) {
            return false;
        }

        if(propertySyntax.Initializer is null) {
            return false;
        }

        var initializerValueSyntax = propertySyntax.Initializer.Value;
        if(initializerValueSyntax is not LiteralExpressionSyntax) {
            return false;
        }

        return true;
    }

    private static SourcePropertyInfo? GetSourcePropertyInfo(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken) {
        if(context.TargetSymbol is not IPropertySymbol propertySymbol || context.TargetNode is not PropertyDeclarationSyntax propertySyntax) {
            return null;
        }

        cancellationToken.ThrowIfCancellationRequested();

        var @namespace = propertySymbol.ContainingNamespace.IsGlobalNamespace ? string.Empty : propertySymbol.ContainingNamespace.ToString();

        var className = propertySymbol.ContainingType.Name;
        var classModifier = propertySymbol.ContainingType.DeclaredAccessibility.ToString().ToLowerInvariant();
        var fullyQualifiedClassName = @namespace + "." + className;

        var propertyName = propertySymbol.Name;

        var initializerValueSyntax = propertySyntax.Initializer.Value as LiteralExpressionSyntax;
        var initialValue = initializerValueSyntax.Token.Value as string;

        return new SourcePropertyInfo(className, fullyQualifiedClassName, classModifier, propertyName, @namespace, initialValue);
    }
}
